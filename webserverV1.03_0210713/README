//项目上的一些问题


#2021年07月09日更新：
发现游双代码实现的服务器不能进行大文件的传输，原因在于传输文件时没有记录文件的尺寸，导致只
有缓冲区容量大小的文件能够传输过去。
游双书上的带读取的文件字节和待发送的文件字节没有处理好，自己要处理好。

#2021年07月10日更新：
加入了定时器：
  创建一个客户链接数组，里面包含了对应的文件描述符和计时器，计时器的任务就是等待15秒关闭链接。每次监听到链接时，创建一个对应文件描述符的计时器，将次计时器更新进入定时器链表，并将倒计时更新为15秒，设置每五秒触发一次ALARM信号。并绑定相应的应该处理函数，执行信号处理函数时，会遍历链表中的所有计时器，将到期的链接关闭。
  值得注意的是如果一个链接反复的发送请求，应该也要更新计时器的时间，不仅如此，最重要的是在读取的时候也要更新，考虑到一些大文件会一直持续读取长达几个小时，所以每次读取操作的时候也要更新计时器记录的时间。
  
解决了webbech测压失败的原因
   设置优雅关闭即可解决，之前设置的是1,0那么close直接立即返回，导致数据没有发送给客户端，导致了webbech测压失败。
   struct linger tmp = {1, 1};//1,0的设置会导致上述问题
   setsockopt(listenfd, SOL_SOCKET, SO_LINGER, &tmp, sizeof(tmp));
   /*设置优雅断开
    #include <arpa/inet.h>
    struct linger {
　　    int l_onoff;
　　    int l_linger;
    };
    三种断开方式：

    1. l_onoff = 0; l_linger忽略
    close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。

    2. l_onoff != 0; l_linger = 0;
    close()立刻返回，但不会发送未发送完成的数据，而是通过一个REST包强制的关闭socket描述符，即强制退出。

    3. l_onoff != 0; l_linger > 0;
    close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送
    完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()
    会直接返回错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵
    塞型，则close()会直接返回值。
    */


#202年07月12日更新

1.把主函数的内容抽象成为了一个server管理类，负责进行主流程的运行

2.发现一个bug，这个bug会导致再多次请求文件，并在文件传输完成前退出，之后，再次链接服务器，
首先会连接上，之后不进行读事件，而是直接触发EPOLLRDHUP信号，该浏览器的任何链接都会触发该
信号，而当我们换一个浏览器登录后，之前的浏览器再次连接时则不会产生EPOLLRDHUP信号。
经测试，如果每次访问中，文件都顺利传输完成，则不会出现上述情况，问题目前还在排查之中。

#2021年07月13日更新：

1.昨天的问题找了很久还没找到原因，暂时搁置。

2.加入了日志系统，可以实现基于阻塞队列的异步日志，和直接写入的同步日志。日志采用单例模式实现，
每次通过一个静态函数调用该实例的指针在进行操作。
  具体实现，将必要的参数通过server类来传入和调用，记录下文件路径和文件名，并且使用fopen "a"的方式创造或者打开
  文件，通过尾部添加的方式写入日志。
  同步、异步具体实现：
    同步在调用的时候直接写入，
    异步在调用的时候不像同步那样直接写入，而是把需要写入的内容作为string传入到定义好了的阻塞队列中，异步
    视线中会独立开一个线程，执行将队列中的string不断写入日志文件的操作。





